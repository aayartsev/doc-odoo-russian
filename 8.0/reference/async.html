<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Asynchronous Operations &mdash; перевод на русский язык документации odoo 8.0</title>

    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/patchqueue.css" type="text/css" />

    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/patchqueue.js"></script>
    <script type="text/javascript" src="../_static/jquery.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap.js"></script>
    <script type="text/javascript" src="../_static/doc.js"></script>
    <script type="text/javascript" src="../_static/jquery.noconflict.js"></script>
    <link rel="top" title="перевод на русский язык документации odoo 8.0" href="../index.html" />
</head>

<body role="document">
    <header class="">
        <figure class="card top">
            <span class="card-img" style="background-image: url('../_static/banners/installing_odoo.jpg');"></span>
        </figure>
    </header>
    <nav id="main_navbar" class="navbar ">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".navbar-main">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <nav class="nav navbar-nav navbar-left">
                    <li id="main-back">
                        <a href="../index.html" class="mdi-navigation-arrow-back"></a>
                    </li>
                    <li>
                        <h1 id="main_title">Asynchronous Operations</h1>
                    </li>
                </nav>
            </div>

            <nav class="collapse navbar-collapse navbar-main navbar-right" role="navigation">

                <ul class="navbar-nav navbar-right nav">
                    <li class="versions">
                        <a class="dropdown-toggle" data-toggle="dropdown">
                8.0 <span class="caret"></span>
              </a>
                        <ul class="dropdown-menu" role="menu">

                            <li><a href="https://www.odoo.com/documentation/9.0/reference/async.html">9.0</a></li>

                        </ul>
                    </li>
                </ul>

                <ul class="navbar-nav navbar-right nav">
                    <li class="toctree-l1 dropdown"><a data-toggle="dropdown" href="../tutorials.html" class="dropdown-toggle internal reference">Tutorials</a>
                        <ul class="dropdown-menu">
                            <li class="toctree-l2"><a href="../howtos/themes.html" class="internal reference">Theme Tutorial</a></li>
                            <li class="toctree-l2"><a href="../howtos/website.html" class="internal reference">Building a Website</a></li>
                            <li class="toctree-l2"><a href="../howtos/backend.html" class="internal reference">Building a Module</a></li>
                            <li class="toctree-l2"><a href="../howtos/web.html" class="internal reference">Building Interface Extensions</a></li>
                        </ul>
                    </li>
                    <li class="toctree-l1"><a href="../api_integration.html" class="internal reference">Web Service API</a>
                        <ul></ul>
                    </li>
                    <li class="toctree-l1 dropdown"><a data-toggle="dropdown" href="../setup.html" class="dropdown-toggle internal reference">Setting Up</a>
                        <ul class="dropdown-menu">
                            <li class="toctree-l2"><a href="../setup/install.html" class="internal reference">Installing Odoo</a></li>
                            <li class="toctree-l2"><a href="../setup/deploy.html" class="internal reference">Deploying Odoo</a></li>
                        </ul>
                    </li>
                    <li class="toctree-l1 dropdown"><a data-toggle="dropdown" href="../reference.html" class="dropdown-toggle internal reference">Reference</a>
                        <ul class="dropdown-menu">
                            <li class="toctree-l2"><a href="orm.html" class="internal reference">ORM API</a></li>
                            <li class="toctree-l2"><a href="data.html" class="internal reference">Data Files</a></li>
                            <li class="toctree-l2"><a href="actions.html" class="internal reference">Actions</a></li>
                            <li class="toctree-l2"><a href="views.html" class="internal reference">Views</a></li>
                            <li class="toctree-l2"><a href="module.html" class="internal reference">Modules</a></li>
                            <li class="toctree-l2"><a href="cmdline.html" class="internal reference">Command-line interface: odoo.py</a></li>
                            <li class="toctree-l2"><a href="security.html" class="internal reference">Security in Odoo</a></li>
                            <li class="toctree-l2"><a href="testing.html" class="internal reference">Testing Modules</a></li>
                            <li class="toctree-l2"><a href="http.html" class="internal reference">Web Controllers</a></li>
                            <li class="toctree-l2"><a href="qweb.html" class="internal reference">QWeb</a></li>
                            <li class="toctree-l2"><a href="javascript.html" class="internal reference">Javascript</a></li>
                            <li class="toctree-l2"><a href="translations.html" class="internal reference">Translating Modules</a></li>
                            <li class="toctree-l2"><a href="reports.html" class="internal reference">QWeb Reports</a></li>
                            <li class="toctree-l2"><a href="workflows.html" class="internal reference">Workflows</a></li>
                            <li class="toctree-l2"><a href="guidelines.html" class="internal reference">Odoo Guidelines</a></li>
                            <li class="toctree-l2"><a href="upgrade_api.html" class="internal reference">Upgrade API</a></li>
                        </ul>
                    </li>
                    <li class="toctree-l1 dropdown"><a data-toggle="dropdown" href="../business.html" class="dropdown-toggle internal reference">Business Mementoes</a>
                        <ul class="dropdown-menu">
                            <li class="toctree-l2"><a href="https://odoo.com/documentation/functional/accounting.html" class="external reference">Accounting Memento (US GAAP)</a></li>
                            <li class="toctree-l2"><a href="https://odoo.com/documentation/functional/double-entry.html" class="external reference">Double-Entry Inventory</a></li>
                            <li class="toctree-l2"><a href="https://odoo.com/documentation/functional/valuation.html" class="external reference">Inventory Valuations</a></li>
                        </ul>
                    </li>
                </ul>
            </nav>
        </div>
    </nav>


    <main class="container ">

        <div class="row">

            <aside>
                <div class="navbar-aside text-center">
                    <div class="logo_box">
                        <span class="logo"></span> Documentation
                    </div>
                    <ul class="list-group text-left nav">
                        <li class="list-group-item"><a href="#deferreds" class="ripple internal reference">Deferreds</a>
                            <ul>
                                <li class="list-group-item"><a href="#using-deferreds" class="ripple internal reference">Using deferreds</a></li>
                                <li class="list-group-item"><a href="#building-deferreds" class="ripple internal reference">Building deferreds</a></li>
                                <li class="list-group-item"><a href="#composing-deferreds" class="ripple internal reference">Composing deferreds</a>
                                    <ul>
                                        <li class="list-group-item"><a href="#deferred-multiplexing" class="ripple internal reference">Deferred multiplexing</a></li>
                                        <li class="list-group-item"><a href="#deferred-chaining" class="ripple internal reference">Deferred chaining</a></li>
                                    </ul>
                                </li>
                                <li class="list-group-item"><a href="#jquery-deferred-api" class="ripple internal reference">jQuery.Deferred API</a></li>
                            </ul>
                        </li>
                    </ul>

                    <p class="gith-container"><a href="https://github.com/odoo/odoo/edit/8.0/doc/reference/async.rst" class="gith-link">
              Edit on GitHub
          </a></p>

                </div>
            </aside>

            <article class="doc-body ">


                <section id="asynchronous-operations"><i id="reference-async"></i>
                    <p>As a language (and runtime), javascript is fundamentally single-threaded. This means any blocking request or computation will block the whole page (and, in older browsers, the software itself even preventing users from switching to
                        another tab): a javascript environment can be seen as an event-based runloop where application developers have no control over the runloop itself.</p>
                    <p>As a result, performing long-running synchronous network requests or other types of complex and expensive accesses is frowned upon and asynchronous APIs are used instead.</p>
                    <p>The goal of this guide is to provide some tools to deal with asynchronous systems, and warn against systemic issues or dangers.</p>
                </section>
                <section id="deferreds">
                    <h2>Deferreds</h2>
                    <p>Deferreds are a form of <a href="http://en.wikipedia.org/wiki/Promise_(programming)" class="external reference">promises</a>. OpenERP Web currently uses
                        <a href="http://api.jquery.com/category/deferred-object/" class="external reference">jQuery's deferred</a>.</p>
                    <p>The core idea of deferreds is that potentially asynchronous methods will return a <a href="#Deferred" class="internal reference" title="Deferred"><code class="js-class xref js">Deferred()</code></a> object instead of an arbitrary value
                        or (most commonly) nothing.</p>
                    <p>This object can then be used to track the end of the asynchronous operation by adding callbacks onto it, either success callbacks or error callbacks.</p>
                    <p>A great advantage of deferreds over simply passing callback functions directly to asynchronous methods is the ability to <a href="#reference-async-composition" class="internal reference"><span >compose them</span></a>.</p>
                </section>
                <section id="using-deferreds">
                    <h3>Using deferreds</h3>
                    <p>Deferreds's most important method is <a href="#Deferred.then" class="internal reference" title="Deferred.then"><code class="js-func xref js">Deferred.then()</code></a>. It is used to attach new callbacks to the deferred object.</p>
                    <ul>
                        <li>the first parameter attaches a success callback, called when the deferred object is successfully resolved and provided with the resolved value(s) for the asynchronous operation.</li>
                        <li>the second parameter attaches a failure callback, called when the deferred object is rejected and provided with rejection values (often some sort of error message).</li>
                    </ul>
                    <p>Callbacks attached to deferreds are never &quot;lost&quot;: if a callback is attached to an already resolved or rejected deferred, the callback will be called (or ignored) immediately. A deferred is also only ever resolved or rejected
                        once, and is either resolved or rejected: a given deferred can not call a single success callback twice, or call both a success and a failure callbacks.</p>
                    <p><a href="#Deferred.then" class="internal reference" title="Deferred.then"><code class="js-func xref js">then()</code></a> should be the method you'll use most often when interacting with deferred objects (and thus asynchronous APIs).</p>
                </section>
                <section id="building-deferreds">
                    <h3>Building deferreds</h3>
                    <p>After using asynchronous APIs may come the time to build them: for
                        <a href="http://en.wikipedia.org/wiki/Mock_object" class="external reference">mocks</a>, to compose deferreds from multiple source in a complex manner, in order to let the current operations repaint the screen or give other events
                        the time to unfold, ...</p>
                    <p>This is easy using jQuery's deferred objects.</p>
                    <div role="alert" class="alert-info alert">
                        <p class="alert-title">Note</p>
                        <p>this section is an implementation detail of jQuery Deferred objects, the creation of promises is not part of any standard (even tentative) that I know of. If you are using deferred objects which are not jQuery's, their API may
                            (and often will) be completely different.</p>
                    </div>
                    <p>Deferreds are created by invoking their constructor <a href="#id3" class="footnote-ref" id="id1">1</a> without any argument. This creates a <a href="#Deferred" class="internal reference" title="Deferred"><code class="js-class xref js">Deferred()</code></a>                        instance object with the following methods:</p>
                    <p><a href="#Deferred.resolve" class="internal reference" title="Deferred.resolve"><code class="js-func xref js">Deferred.resolve()</code></a></p>
                    <blockquote>As its name indicates, this method moves the deferred to the &quot;Resolved&quot; state. It can be provided as many arguments as necessary, these arguments will be provided to any pending success callback.
                    </blockquote>
                    <p><a href="#Deferred.reject" class="internal reference" title="Deferred.reject"><code class="js-func xref js">Deferred.reject()</code></a></p>
                    <blockquote>Similar to <a href="#Deferred.resolve" class="internal reference" title="Deferred.resolve"><code class="js-func xref js">resolve()</code></a>, but moves the deferred to the &quot;Rejected&quot; state and calls pending failure handlers.</blockquote>
                    <p><a href="#Deferred.promise" class="internal reference" title="Deferred.promise"><code class="js-func xref js">Deferred.promise()</code></a></p>
                    <blockquote>Creates a readonly view of the deferred object. It is generally a good idea to return a promise view of the deferred to prevent callers from resolving or rejecting the deferred in your stead.</blockquote>
                    <p><a href="#Deferred.reject" class="internal reference" title="Deferred.reject"><code class="js-func xref js">reject()</code></a> and <a href="#Deferred.resolve" class="internal reference" title="Deferred.resolve"><code class="js-func xref js">resolve()</code></a>                        are used to inform callers that the asynchronous operation has failed (or succeeded). These methods should simply be called when the asynchronous operation has ended, to notify anybody interested in its result(s).
                    </p>
                </section>
                <section id="composing-deferreds"><i id="reference-async-composition"></i>
                    <h3>Composing deferreds</h3>
                    <p>What we've seen so far is pretty nice, but mostly doable by passing functions to other functions (well adding functions post-facto would probably be a chore... still, doable).</p>
                    <p>Deferreds truly shine when code needs to compose asynchronous operations in some way or other, as they can be used as a basis for such composition.</p>
                    <p>There are two main forms of compositions over deferred: multiplexing and piping/cascading.</p>
                </section>
                <section id="deferred-multiplexing">
                    <h4>Deferred multiplexing</h4>
                    <p>The most common reason for multiplexing deferred is simply performing multiple asynchronous operations and wanting to wait until all of them are done before moving on (and executing more stuff).</p>
                    <p>The jQuery multiplexing function for promises is <a href="#when" class="internal reference" title="when"><code class="js-func xref js">when()</code></a>.</p>
                    <div role="alert" class="alert-info alert">
                        <p class="alert-title">Note</p>
                        <p>the multiplexing behavior of jQuery's <a href="#when" class="internal alert-link reference" title="when"><code class="js-func xref js">when()</code></a> is an (incompatible, mostly) extension of the behavior defined in
                            <a href="http://wiki.commonjs.org/wiki/Promises/B" class="external reference alert-link">CommonJS Promises/B</a>.</p>
                    </div>
                    <p>This function can take any number of promises <a href="#id4" class="footnote-ref" id="id2">2</a> and will return a promise.
                    </p>
                    <p>The returned promise will be resolved when <em>all</em> multiplexed promises are resolved, and will be rejected as soon as one of the multiplexed promises is rejected (it behaves like Python's <code>all()</code>, but with promise objects
                        instead of boolean-ish).</p>
                    <p>The resolved values of the various promises multiplexed via
                        <a href="#when" class="internal reference" title="when"><code class="js-func xref js">when()</code></a> are mapped to the arguments of <a href="#when" class="internal reference" title="when"><code class="js-func xref js">when()</code></a>'s
                        success callback, if they are needed. The resolved values of a promise are at the same index in the callback's arguments as the promise in the <a href="#when" class="internal reference" title="when"><code class="js-func xref js">when()</code></a>                        call so you will have:</p>
                    <div class="highlight-javascript">
                        <div class="highlight"><pre><span class="nx">$</span><span class="p">.</span><span class="nx">when</span><span class="p">(</span><span class="nx">p0</span><span class="p">,</span> <span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
        <span class="kd">function</span> <span class="p">(</span><span class="nx">results0</span><span class="p">,</span> <span class="nx">results1</span><span class="p">,</span> <span class="nx">results2</span><span class="p">,</span> <span class="nx">results3</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// code</span>
<span class="p">});</span>
</pre></div>
                    </div>
                    <div role="alert" class="alert-warning alert">
                        <p class="alert-title">Warning</p>
                        <p>in a normal mapping, each parameter to the callback would be an array: each promise is conceptually resolved with an array of 0..n values and these values are passed to
                            <a href="#when" class="internal alert-link reference" title="when"><code class="js-func xref js">when()</code></a>'s callback. But jQuery treats deferreds resolving a single value specially, and &quot;unwraps&quot; that value.</p>
                        <p>For instance, in the code block above if the index of each promise is the number of values it resolves (0 to 3), <code>results0</code> is an empty array, <code>results2</code> is an array of 2 elements (a pair) but
                            <code>results1</code> is the actual value resolved by <code>p1</code>, not an array.</p>
                    </div>
                </section>
                <section id="deferred-chaining">
                    <h4>Deferred chaining</h4>
                    <p>A second useful composition is starting an asynchronous operation as the result of an other asynchronous operation, and wanting the result of both: with the tools described so far, handling e.g. OpenERP's search/read sequence with
                        this would require something along the lines of:
                    </p>
                    <div class="highlight-javascript">
                        <div class="highlight"><pre><span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">Deferred</span><span class="p">();</span>
<span class="nx">Model</span><span class="p">.</span><span class="nx">search</span><span class="p">(</span><span class="nx">condition</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">ids</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">Model</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="nx">ids</span><span class="p">,</span> <span class="nx">fields</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">records</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">result</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">records</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
<span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">promise</span><span class="p">();</span>
</pre></div>
                    </div>
                    <p>While it doesn't look too bad for trivial code, this quickly gets unwieldy.
                    </p>
                    <p>But <a href="#Deferred.then" class="internal reference" title="Deferred.then"><code class="js-func xref js">then()</code></a> also allows handling this kind of chains: it returns a new promise object, not the one it was called with,
                        and the return values of the callbacks is important to this behavior: whichever callback is called,</p>
                    <ul>
                        <li>If the callback is not set (not provided or left to null), the resolution or rejection value(s) is simply forwarded to
                            <a href="#Deferred.then" class="internal reference" title="Deferred.then"><code class="js-func xref js">then()</code></a>'s promise (it's essentially a noop)</li>
                        <li>
                            <p>If the callback is set and does not return an observable object (a deferred or a promise), the value it returns (<code>undefined</code> if it does not return anything) will replace the value it was given, e.g.</p>
                            <div class="highlight-javascript">
                                <div class="highlight"><pre><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;called&#39;</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
                            </div>
                            <p>will resolve with the sole value <code>undefined</code>.</p>
                        </li>
                        <li>
                            <p>If the callback is set and returns an observable object, that object will be the actual resolution (and result) of the pipe. This means a resolved promise from the failure callback will resolve the pipe, and a failure promise
                                from the success callback will reject the pipe.
                            </p>
                            <p>This provides an easy way to chain operation successes, and the previous piece of code can now be rewritten:</p>
                            <div class="highlight-javascript">
                                <div class="highlight"><pre><span class="k">return</span> <span class="nx">Model</span><span class="p">.</span><span class="nx">search</span><span class="p">(</span><span class="nx">condition</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">ids</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Model</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="nx">ids</span><span class="p">,</span> <span class="nx">fields</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
                            </div>
                            <p>the result of the whole expression will encode failure if either
                                <code>search</code> or <code>read</code> fails (with the right rejection values), and will be resolved with <code>read</code>'s resolution values if the chain executes correctly.</p>
                        </li>
                    </ul>
                    <p><a href="#Deferred.then" class="internal reference" title="Deferred.then"><code class="js-func xref js">then()</code></a> is also useful to adapt third-party promise-based APIs, in order to filter their resolution value counts for
                        instance (to take advantage of <a href="#when" class="internal reference" title="when"><code class="js-func xref js">when()</code></a> 's special treatment of single-value promises).</p>
                </section>
                <section id="jquery-deferred-api">
                    <h3>jQuery.Deferred API</h3>
                    <section class="code-function">
                        <h6 id="when"><code>when(<em>deferreds…</em>)</code></h6>
                        <div class="code-fields">
                            <div class="code-field">
                                <div class="code-field-name">Arguments</div>
                                <div class="code-field-body">
                                    <ul>
                                        <li><strong>deferreds</strong> -- deferred objects to multiplex</li>
                                    </ul>
                                </div>
                            </div>
                            <div class="code-field">
                                <div class="code-field-name">Returns</div>
                                <div class="code-field-body">a multiplexed deferred</div>
                            </div>
                            <div class="code-field">
                                <div class="code-field-name">Return type</div>
                                <div class="code-field-body"><a href="#Deferred" class="internal alert-link reference" title="Deferred"><code class="js-class xref js">Deferred()</code></a></div>
                            </div>
                        </div>
                    </section>
                    <section class="code-class">
                        <h6 id="Deferred"><code><em >class </em>Deferred()</code></h6>
                        <section class="code-function">
                            <h6 id="Deferred.then"><code>Deferred.then(<em>doneCallback</em>[, <em>failCallback</em>])</code></h6>
                            <p>Attaches new callbacks to the resolution or rejection of the deferred object. Callbacks are executed in the order they are attached to the deferred.</p>
                            <p>To provide only a failure callback, pass <code>null</code> as the
                                <code>doneCallback</code>, to provide only a success callback the second argument can just be ignored (and not passed at all).</p>
                            <p>Returns a new deferred which resolves to the result of the corresponding callback, if a callback returns a deferred itself that new deferred will be used as the resolution of the chain.
                            </p>
                            <div class="code-fields">
                                <div class="code-field">
                                    <div class="code-field-name">Arguments</div>
                                    <div class="code-field-body">
                                        <ul>
                                            <li><strong>doneCallback</strong> -- function called when the deferred is resolved</li>
                                            <li><strong>failCallback</strong> -- function called when the deferred is rejected</li>
                                        </ul>
                                    </div>
                                </div>
                                <div class="code-field">
                                    <div class="code-field-name">Returns</div>
                                    <div class="code-field-body">the deferred object on which it was called</div>
                                </div>
                                <div class="code-field">
                                    <div class="code-field-name">Return type</div>
                                    <div class="code-field-body"><a href="#Deferred" class="internal alert-link reference" title="Deferred"><code class="js-class xref js">Deferred()</code></a></div>
                                </div>
                            </div>
                        </section>
                        <section class="code-function">
                            <h6 id="Deferred.done"><code>Deferred.done(<em>doneCallback</em>)</code></h6>
                            <p>Attaches a new success callback to the deferred, shortcut for
                                <code>deferred.then(doneCallback)</code>.</p>
                            <div role="alert" class="alert-info alert">
                                <p class="alert-title">Note</p>
                                <p>a difference is the result of <a href="#Deferred.done" class="internal alert-link reference" title="Deferred.done"><code class="js-func xref js">Deferred.done()</code></a>'s is ignored rather than forwarded through the
                                    chain</p>
                            </div>
                            <p>This is a jQuery extension to <a href="http://wiki.commonjs.org/wiki/Promises/A" class="external reference alert-link">CommonJS Promises/A</a> providing little value over calling <a href="#Deferred.then" class="internal alert-link reference"
                                    title="Deferred.then"><code class="js-func xref js">then()</code></a> directly, it should be avoided.</p>
                            <div class="code-fields">
                                <div class="code-field">
                                    <div class="code-field-name">Arguments</div>
                                    <div class="code-field-body">
                                        <ul>
                                            <li><strong>doneCallback</strong> (<em>Function</em>) -- function called when the deferred is resolved</li>
                                        </ul>
                                    </div>
                                </div>
                                <div class="code-field">
                                    <div class="code-field-name">Returns</div>
                                    <div class="code-field-body">the deferred object on which it was called</div>
                                </div>
                                <div class="code-field">
                                    <div class="code-field-name">Return type</div>
                                    <div class="code-field-body"><a href="#Deferred" class="internal alert-link reference" title="Deferred"><code class="js-class xref js">Deferred()</code></a></div>
                                </div>
                            </div>
                        </section>
                        <section class="code-function">
                            <h6 id="Deferred.fail"><code>Deferred.fail(<em>failCallback</em>)</code></h6>
                            <p>Attaches a new failure callback to the deferred, shortcut for
                                <code>deferred.then(null, failCallback)</code>.</p>
                            <p>A second jQuery extension to <a href="CommonJSPromises/A" class="external reference alert-link">Promises/A</a>. Although it provides more value than
                                <a href="#Deferred.done" class="internal alert-link reference" title="Deferred.done"><code class="js-func xref js">done()</code></a>, it still is not much and should be avoided as well.</p>
                            <div class="code-fields">
                                <div class="code-field">
                                    <div class="code-field-name">Arguments</div>
                                    <div class="code-field-body">
                                        <ul>
                                            <li><strong>failCallback</strong> (<em>Function</em>) -- function called when the deferred is rejected</li>
                                        </ul>
                                    </div>
                                </div>
                                <div class="code-field">
                                    <div class="code-field-name">Returns</div>
                                    <div class="code-field-body">the deferred object on which it was called</div>
                                </div>
                                <div class="code-field">
                                    <div class="code-field-name">Return type</div>
                                    <div class="code-field-body"><a href="#Deferred" class="internal alert-link reference" title="Deferred"><code class="js-class xref js">Deferred()</code></a></div>
                                </div>
                            </div>
                        </section>
                        <section class="code-function">
                            <h6 id="Deferred.promise"><code>Deferred.promise()</code></h6>
                            <p>Returns a read-only view of the deferred object, with all mutators (resolve and reject) methods removed.</p>
                        </section>
                        <section class="code-function">
                            <h6 id="Deferred.resolve"><code>Deferred.resolve(<em>value…</em>)</code></h6>
                            <p>Called to resolve a deferred, any value provided will be passed onto the success handlers of the deferred object.</p>
                            <p>Resolving a deferred which has already been resolved or rejected has no effect.</p>
                        </section>
                        <section class="code-function">
                            <h6 id="Deferred.reject"><code>Deferred.reject(<em>value…</em>)</code></h6>
                            <p>Called to reject (fail) a deferred, any value provided will be passed onto the failure handler of the deferred object.</p>
                            <p>Rejecting a deferred which has already been resolved or rejected has no effect.</p>
                        </section>
                    </section>
                    <div class="footnote" id="id3"><span class="footnote-label"><a class="footnote-backref" href="#id1">[1]</a></span> or simply calling <a href="#Deferred" class="internal reference" title="Deferred"><code class="js-class xref js">Deferred()</code></a> as a function,
                        the result is the same</div>
                    <div class="footnote" id="id4"><span class="footnote-label"><a class="footnote-backref" href="#id2">[2]</a></span>
                        <p>or not-promises, the <a href="http://wiki.commonjs.org/wiki/Promises/B" class="external reference">CommonJS Promises/B</a> role of
                            <a href="#when" class="internal reference" title="when"><code class="js-func xref js">when()</code></a> is to be able to treat values and promises uniformly: <a href="#when" class="internal reference" title="when"><code class="js-func xref js">when()</code></a>                            will pass promises through directly, but non-promise values and objects will be transformed into a resolved promise (resolving themselves with the value itself).</p>
                        <p>jQuery's <a href="#when" class="internal reference" title="when"><code class="js-func xref js">when()</code></a> keeps this behavior making deferreds easy to build from &quot;static&quot; values, or allowing defensive code where
                            expected promises are wrapped in <a href="#when" class="internal reference" title="when"><code class="js-func xref js">when()</code></a> just in case.
                        </p>
                    </div>
                </section>

            </article>
        </div>

        <div id="mask"></div>
    </main>

    <div class="floating_action_container">
        <a id="floating_action" class="ripple" href="#">
            <i class="mdi-action-explore"></i>
        </a>
        <div id="floating_action_menu">
            <span class="bubble"></span>
            <ul class="list-group content">
                <li class="list-group-item ripple"><a>Cras justo odio</a></li>
                <li class="list-group-item ripple"><a>Dapibus ac facilisis in</a></li>
                <li class="list-group-item ripple"><a>Morbi leo risus</a></li>
                <li class="list-group-item ripple"><a>Porta ac consectetur ac</a></li>
                <li class="list-group-item ripple"><a>Vestibulum at eros</a></li>
            </ul>
        </div>
    </div>

<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function(d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter42690849 = new Ya.Metrika({
                    id: 42690849,
                    clickmap: true,
                    trackLinks: true,
                    accurateTrackBounce: true,
                    webvisor: true,
                    trackHash: true
                });
            } catch (e) {}
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function() {
                n.parentNode.insertBefore(s, n);
            };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else {
            f();
        }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/42690849" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
</body>

</html>
